[
  {
    "Id": "271370",
    "ThreadId": "79258",
    "Html": "<p>Hi,</p>\r\n<p>In my application, I get data for a large number of variables (e.g. a1,a2 .. a100). I need to compute an expression based on some of these variables (e.g. a1+a34+a49). This expression is defined by the user at application runtime.</p>\r\n<p>Is there a way that I can find out which variables are being used in the expression, so that I can add only those parameters in the expression through Parameters collection. I am looking for something like the following pseudo code:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Blue\">public</span> <span style=\"color:Blue\">object</span> Evaluate(<span style=\"color:Blue\">string</span> sFormula, ValueCollection values)\r\n{\r\n   Expression expression = <span style=\"color:Blue\">new</span> Expression(sFormula);\r\n   \r\n   // get list of variables used in the expression<br>   <span style=\"color:Blue\">string</span>[] variables = expression.GetVariablesList();\r\n\r\n   <span style=\"color:Blue\">for</span>(<span style=\"color:Blue\">int</span> i = 0; i &lt; variables.Length; i++)\r\n   {\r\n      <span style=\"color:Blue\">string</span> sParamName = variables[i];\r\n<br>      // Get current value of variable<br>      <span style=\"color:Blue\">object</span> oValue = ValueCollection[sParamName];\r\n<br>      // add variable value to the expression<br>      expression.Parameters[sParamName] = oValue;\r\n   }\r\n\r\n   <span style=\"color:Blue\">return</span> expression.Evaluate();\r\n}\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>Is there something equivalent of <strong>GetVariablesList </strong>that could get me the list of variables being used in an expression?</p>\r\n<p>I know I can do this by blindly adding all the variables to expression evaluator, but obviously there could be performance hit.</p>\r\n<p><br>Thanks &amp; Regards,</p>\r\n<p>- Vikram Lele</p>",
    "PostedDate": "2009-12-29T01:46:11.923-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "271395",
    "ThreadId": "79258",
    "Html": "<p>Hi,<br><br>I could not find any readymade function in NCalc to do this. So I have written quick and dirty recursive function to do this:</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Blue\">private</span> <span style=\"color:Blue\">void</span> ExtractIdentifiers(LogicalExpression expression, List&lt;<span style=\"color:Blue\">string</span>&gt; identifiers)<br>{<br>   <span style=\"color:Blue\">if</span> (expression <span style=\"color:Blue\">is</span> UnaryExpression)<br>   <span style=\"color:Blue\">&nbsp;</span>{<br>      <span style=\"color:Blue\">&nbsp;</span>UnaryExpression ue = expression <span style=\"color:Blue\">as</span> UnaryExpression;<br><br>      ExtractIdentifiers(ue.Expression, identifiers);<br>   }<br>   <span style=\"color:Blue\">else</span> <span style=\"color:Blue\">if</span> (expression <span style=\"color:Blue\">is</span> BinaryExpression)<br>   {<br>      BinaryExpression be = expression <span style=\"color:Blue\">as</span> BinaryExpression;<br><br>      ExtractIdentifiers(be.LeftExpression, identifiers);<br>      ExtractIdentifiers(be.RightExpression, identifiers);<br>   }<br>   <span style=\"color:Blue\">else</span> <span style=\"color:Blue\">if</span> (expression <span style=\"color:Blue\">is</span> TernaryExpression)<br>   {<br>      TernaryExpression te = expression <span style=\"color:Blue\">as</span> TernaryExpression;<br><br>      ExtractIdentifiers(te.LeftExpression, identifiers);<br>      ExtractIdentifiers(te.MiddleExpression, identifiers);<br>      ExtractIdentifiers(te.RightExpression, identifiers);<br>   }<br>   <span style=\"color:Blue\">else</span> <span style=\"color:Blue\">if</span> (expression <span style=\"color:Blue\">is</span> Function)<br>   {<br>      Function fn = expression <span style=\"color:Blue\">as</span> Function;<br><br>      LogicalExpression[] expressions = fn.Expressions;<br>      <span style=\"color:Blue\">if</span> (expressions != <span style=\"color:Blue\">null</span> &amp;&amp; expressions.Length &gt; 0)<br>      {<br>         <span style=\"color:Blue\">for</span> (<span style=\"color:Blue\">int</span> i = 0; i &lt; expressions.Length; i++)<br>         {<br>            ExtractIdentifiers(expressions[i], identifiers);<br>         }<br>      }<br>   }<br>   <span style=\"color:Blue\">else</span> <span style=\"color:Blue\">if</span> (expression <span style=\"color:Blue\">is</span> Identifier)<br>   {<br>      Identifier identifier = expression <span style=\"color:Blue\">as</span> Identifier;<br><br>      <span style=\"color:Blue\">if</span> (!identifiers.Contains(identifier.Name))<br>      {<br>         identifiers.Add(identifier.Name);<br>      }<br>   }<br>}</pre>\r\n</div>\r\n<p>You must first call HasErrors to ensure that the expression gets parsed before this function could be used.<br>Here is how I use it :</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>Expression expression = <span style=\"color:Blue\">new</span> Expression(sExpression, EvaluateOptions.IgnoreCase);\r\n\r\nList&lt;<span style=\"color:Blue\">string</span>&gt; identifiers = <span style=\"color:Blue\">new</span> List&lt;<span style=\"color:Blue\">string</span>&gt;();\r\n<span style=\"color:Blue\">bool</span> bHasErrors = expression.HasErrors();\r\n<span style=\"color:Blue\">if</span> (!bHasErrors)\r\n{\r\n   ExtractIdentifiers(expression.ParsedExpression, identifiers);\r\n}\r\n\r\n\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>Now I have a few more queries:</p>\r\n<p>a. Is there any better way of doing this?</p>\r\n<p>b. Does this cover all scenarios?</p>\r\n<p>c. Can this feature be made part of NCalc library?</p>\r\n<p>If this feature could be part of NCalc library, then better approach could be to add a property to LogicalExpression to get all identifiers used by that expression. This could recursively operate to get the list of identifiers without resorting to the type casting approach that I have used here.</p>\r\n<p>&nbsp;</p>\r\n<p>Regards,</p>\r\n<p>- Vikram Lele</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<div id=\"_mcePaste\" style=\"overflow:hidden;left:-10000px;top:0px;width:1px;height:1px\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private void ExtractIdentifiers(LogicalExpression expression, List&lt;string&gt; identifiers)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (expression is UnaryExpression)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UnaryExpression ue = expression as UnaryExpression;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExtractIdentifiers(ue.Expression, identifiers);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (expression is BinaryExpression)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BinaryExpression be = expression as BinaryExpression;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExtractIdentifiers(be.LeftExpression, identifiers);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExtractIdentifiers(be.RightExpression, identifiers);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (expression is TernaryExpression)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TernaryExpression te = expression as TernaryExpression;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExtractIdentifiers(te.LeftExpression, identifiers);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExtractIdentifiers(te.MiddleExpression, identifiers);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExtractIdentifiers(te.RightExpression, identifiers);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (expression is Function)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Function fn = expression as Function;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LogicalExpression[] expressions = fn.Expressions;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (expressions != null &amp;&amp; expressions.Length &gt; 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; expressions.Length; i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExtractIdentifiers(expressions[i], identifiers);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (expression is Identifier)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Identifier identifier = expression as Identifier;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!identifiers.Contains(identifier.Name))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; identifiers.Add(identifier.Name);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br></div>",
    "PostedDate": "2009-12-29T03:38:07.253-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "271493",
    "ThreadId": "79258",
    "Html": "<p>I would have done it by implementing a specific visitor for that, implementing each of the Visit(Expression) overload.</p>\r\n<p>Optionally, you can also not define any parameter, and define a delegate for the parameters. Then you can only give the requested value on demand. To see if it's a performance optimization you should make some tests.</p>",
    "PostedDate": "2009-12-29T10:42:40.65-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "705565",
    "ThreadId": "79258",
    "Html": "<p>How about using the parameter delegate&nbsp;like this:</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>        <span style=\"color: blue;\">public</span> List&lt;<span style=\"color: blue;\">string</span>&gt; GetParameters(<span style=\"color: blue;\">string</span> expression)\r\n        {\r\n            List&lt;<span style=\"color: blue;\">string</span>&gt; parameters = <span style=\"color: blue;\">new</span> List&lt;<span style=\"color: blue;\">string</span>&gt;();\r\n\r\n            Random random = <span style=\"color: blue;\">new</span> Random();\r\n\r\n            Expression e = <span style=\"color: blue;\">new</span> Expression(expression);\r\n\r\n            e.EvaluateParameter += <span style=\"color: blue;\">delegate</span>(<span style=\"color: blue;\">string</span> name, ParameterArgs args)\r\n            {\r\n                parameters.Add(name);\r\n                args.Result = random.Next(0, 100);\r\n            };\r\n\r\n            <span style=\"color: blue;\">try</span>\r\n            {\r\n                e.Evaluate();\r\n            }\r\n            <span style=\"color: blue;\">catch</span>\r\n            {\r\n            }\r\n\r\n            <span style=\"color: blue;\">return</span> parameters;\r\n        }\r\n\r\n</pre>\r\n</div>",
    "PostedDate": "2011-11-30T15:17:13.527-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1310045",
    "ThreadId": "79258",
    "Html": "This did not work for me, but when I added an EvaluateFunction delegate, it worked like a charm.  Thanks for the lead.<br />\n<pre><code>            e.EvaluateFunction += delegate(string name, NCalc.FunctionArgs args) {\n                args.EvaluateParameters();\n                args.Result = random.Next(0, 100);\n            };</code></pre>\n\n",
    "PostedDate": "2014-10-02T13:36:27.277-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1450701",
    "ThreadId": "79258",
    "Html": "Be careful, I don't think using EvaluateParameter and EvaluateFunction delegates to record the name will work reliably for a Logical/Binary expression since the expression evaluator uses short circuit evaluation.  So if you have and expression like: &quot;(A &gt; 10) &amp;&amp; (B &lt; 5)&quot; and if you give it a dummy &quot;A&quot; value that's &gt; 10, then it won't evaluate the &quot;(B &lt; 5)&quot; and the EvaluateParameter call won't be made for &quot;(B &lt; 5)&quot; so you won't get the &quot;B&quot; parameter.  In this situation I think &quot;viklele&quot; is the right approach (not sure if it covers all cases).<br />\n",
    "PostedDate": "2015-11-02T14:18:20.93-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]